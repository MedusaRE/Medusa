\documentclass{article}

\usepackage[pdftex, pdfborderstyle={/S/U/W 0}, breaklinks=false]{hyperref}
\usepackage{comment}
\usepackage{xspace}

\newcommand{\xpDBG}{\textit{xp$^{DBG}$}\xspace}

\begin{comment}
	Add your preferred name to the \author section if you edit this file.
\end{comment}

\title{The Medusa Project}
\author{spv}

\begin{document}
	\maketitle

	\section{Notes}
	\begin{enumerate}
		\item This document / paper / book is written from the perspective of
		the \textit{Medusa} Project's main developer, spv.

		\item All software released by the \textit{Medusa} Project is, whenever
		possible, released under the GNU General Public License, Version 2
		(without the "any later version" clause).

		\item This document / paper / book was partially written by me (spv) in
		order to learn \LaTeX.

		\item Documentation for \textit{Medusa} Project API's can be found at
		
		\href{https://docs.medusa-re.org}{docs.medusa-re.org}.

		\item A wiki for the \textit{Medusa} Project can be found at
		\href{https://wiki.medusa-re.org}{wiki.medusa-re.org}.
	\end{enumerate}

	\section{Introduction}
	\textit{Medusa} is a project to create a cross platform, free (libre), and
	general purpose tool for software and hardware research, like reverse
	engineering, analysis, emulation, development, debugging, and other similar
	tasks. I started the \textit{Medusa} project originally under the name of
	\xpDBG, as a hobby project to learn about reverse engineering, and because I
	felt that current development and reverse engineering tools all have their
	own problems, which I wanted to solve.

	\subsection{Current Tools' Issues}
	This subsection is partially paraphrased from the \textit{Medusa} Project's
	\texttt{README.md} file.

	\begin{itemize}
		\item \textit{Cutter}: not very featureful, essentially a
		\textit{radare2} GUI, and doesn't have debugger and/or emulation support
		to my knowledge.
		\item \textit{Ghidra}: personal favorite currently, still doesn't have
		emulation support or code editing, and is written in Java (besides the
		decompiler), which is one of my least favorite languages*.
		\item \textit{IDA Pro}: expensive, non-free, does not have emulation
		support, or code editing.
		\item \textit{Radare2}: does not have code editing, a GUI, or the level
		of emulation support which I intend to include in \textit{Medusa}.
		\item \textit{Binary Ninja}: I honestly do not have a lot of experience
		with \textit{Binary Ninja}, but to my knowledge, it is not free / 
		open-source software, it isn't a full IDE (like \textit{Medusa} is
		intended to be), and doesn't have emulation support (like
		\textit{Medusa} is intended to).
	\end{itemize}

	* Since the writing of \texttt{README.md}, I have changed my opinion slightly
	in regards to Java. I still dislike parts of the language (particularly,
	requiring a VM), but I can appreciate other parts of it.

	\subsection{\textit{Medusa}'s Solutions}
	\subsubsection{\textit{libmedusa}}
	For a first example, take \textit{Unicorn}. \textit{Unicorn} is a
	library/API based on \textit{QEMU}, that provides an interface to control
	virtualized/emulated CPUs, and general machines. I do appreciate the
	\textit{Unicorn} project's work, but I think it has some flaws. (or rather,
	it is not the perfect library for the \textit{Medusa} Project's goals.)

	To solve some of \textit{Unicorn}'s issues, the \textit{Medusa} Project has
	a subproject / subcomponent called \textit{libmedusa}. \textit{libmedusa} is
	a C++ library with a "standardized" API for interfacing with emulated
	machines ("soft silicon", as I call it), as well as real machines ("hard
	silicon", as I call it). \textit{libmedusa} also provides a "standardized"
	API for interacting with other types of components, such as displays, sound
	outputs, and other components useful when controlling, say, an emulated
	Commodore 64. If you wanted to do so, you could provide an implementation of
	the \textit{libmedusa} API for emulators for the 6502, SID, VIC-II, and
	other components. (or even real hardware!) Then, other software can
	interface with an emulated, or even a real C64, without needing to be
	specifically written to support it.

	Another way that this API could be useful is if you (or your company) is
	developing a new piece of hardware. \textit{Medusa} (or other software)
	probably doesn't support unreleased hardware, and with other software, say
	\textit{IDA Pro} (or something with emulation support) it may be difficult
	to emulate your hardware elegantly for testing purposes. With
	\textit{libmedusa}, you could implement its API for your particular display,
	sound output, CPU, etc, (or even re-use existing implementations, if, say,
	you use a standard CPU ISA, like \textit{ARMv8}), and software can interact
	with your hardware without needing to be specifically written to support it.

	\textit{libmedusa} doesn't just provide an alternative to \textit{Unicorn}.
	It provides an all-in-one API that can replace \textit{Unicorn},
	\textit{Capstone}, \textit{Keystone}, \textit{LIEF} (\textit{libmedusa}
	provides an API for parsing formats like ELF), and other libraries.

	\subsubsection{\textit{barcelona}}
	This subsubsection is adapted from the \textit{barcelona} subcomponent /
	subproject's \texttt{README.md} file.

	\textit{barcelona} is a subproject of the \textit{Medusa} Project to create
	a TUI (Terminal User Interface)-based IDE (Integrated Development
	Environment).

	\subsubsection{\textit{paris}}
	This subsubsection is adapted from the \textit{paris} subproject's
	\texttt{README.md}.

	\textit{paris} is a subcomponent of the \textit{Medusa} Project to develop
	the client/server architecture that is intended to be used in the project.
	\textit{Medusa} is meant to be modeled after a client/server architecture,
	where a machine (or machines) operates the server, and handle the bulk of
	the processing work; and a machine (or machines) runs a client, which
	connects to the server, and provides a UI to interface with the server.

	The server can be the same machine as the client, and it does not need to be
	over the network (i.e. TCP), it could be a socket, for example.

	\subsubsection{\textit{rome}}
	This subsubsection is adapted from the \textit{rome} subcomponent's
	\texttt{README.md} file.

	Rome is a subcomponent of the \textit{Medusa} Project to write a modern C++
	TUI framework based on \textit{ncurses}. \textit{ncurses} / \textit{curses}
	is a great framework, but in my (spv) opinion, it feels a bit ancient
	compared to what could be done with, say, C++. It's a bit low-level, and the
	code you write with it is, in my opinion, not the best-looking, to put it
	mildly.

	I do understand the historical reason(s) for the \textit{curses} API
	essentially using $(y,x)$ instead of $(x,y)$, but it doesn't make it any
	less strange to write.

	\section{History}
	The \textit{Medusa} Project's history begins with another one of my
	projects, \textit{p0laris}. I, at the time, was writing shellcode to execute
	from within kernel-land on iOS 9, and wanted to debug said shellcode. I did
	not (and still don't, at the time of writing) own a DCSD-cable, or other
	similar means to debug the shellcode, so I set out to develop a debugger I
	could run on my computer.

	I discussed \xpDBG in the \textit{Introduction} section, but before even
	\xpDBG, I created a small project called \textit{ARMistice}.
	\textit{ARMistice} was a small \textit{Python} script that emulated an
	\textit{ARMv7} CPU using \textit{Unicorn}, and provided memory editing,
	assembly, disassembly, and a UI with \textit{ncurses}, \textit{Keystone},
	and \textit{Capstone}. This little \textit{Python} script was the genesis
	for what would eventually become the \textit{Medusa} Project.
	
	After \textit{ARMistice}, as was stated in the \textit{Introduction}
	section, the \textit{Medusa} project was started under a different name,
	\xpDBG. \xpDBG stands (or rather, stood) for "cross (X) Platform
	DeBuGger", which references the project's goal to create a cross platform
	suite for software and hardware research. 
\end{document}
